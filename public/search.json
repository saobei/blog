[{"title":"angular从入门到入土系列01","url":"/blog/2020/10/22/angular-learn01/","content":"\n### angular从入门到入土系列01 -- Angular各个版本差异和应用架构设计\n\n#### 学习路线规划\n\n+ Angular各个版本差异和应用架构设计\n+ 过一遍[官方文档](https://angular.cn/guide/architecture-modules)，理清专业术语和掌握基础知识 \n+ [Angular In Depth](https://zhuanlan.zhihu.com/DepthInAngular)文章过一遍\n+ [30天精通Rxjs系列](https://ithelp.ithome.com.tw/users/20103367/ironman/1199)\n+ [读完教程和文档](https://www.typescriptlang.org/docs/handbook/intro.html)，掌握Ts基础\n+ 学习组件库 ng-zorro-antd， Angular Material\n+ 上手项目实践\n\n\n#### 第一步 了解背景\n\n对于刚接触Angular的新手来说，第一步无非是打基础，也是基础的一步\n\nAngularJs是google发布的第一个MVC框架，带来了许多新特性，为前端开发提供了很多新的思路，线上直到现在还有许多大型产品在用AngularjJs.\n\nAngularJs实际上是Angular2+，官方推崇类似Chrome的版本迭代理念，让开发者淡化对版本号的变化感知，希望这个框架可以持续发展。Angular是个重架构，提供了模块、组件、装饰器、服务等多种功能组件，编译方式也从JIT(just in time)逐渐过度到AOT(Ahead of time)，不断的优化性能及功能。\n\n而TS的加入也让angular如虎添翼，ts吸取了许多面向对象的编程语言优势，比如java,这样让前端的规模化协作开发不再是难题，工程质量也大幅提升。但是ng也有自身的问题，学习曲线陡峭，对开发人员的整体数值要求还是过高；还有ngzone的性能也是个问题，对外不是太友好，默认截获了所有的浏览器事件\n和方法，调优难度和第三方产品对接难度都比较大。\n\n\n> Angular版本差异？如何选择合适的版本？\n\n+ 2009 -- AngularJs \n\n    AngularJS 诞生于2009年，bai由Misko Hevery 等人创建，后为Google所收购。是一款优du秀的前端zhiJS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等\n\n+ 2016 -- Angular2 \n    \n    整个重写了1.x, 变得更加简洁，最核心的概念只剩下一个，那就是componnent,其他所有一切都是围绕着Component展开的。从这点看Angular2无疑是收到了React的强力影响，毕竟React的核心概念也只有一个，也是component，所以在使用ng2的时候，大家只需要会写Component就行了，其他的那些什么服务啊，路由啊，管道啊，都是小工具而已。接下来罗列一下Angular2与之前的1.x相比带来的核心改变:\n    \n    +  Angular删掉了$scope的概念。\n        \n        在ng1.x里面，$scope是一个相当强大又相当可怕的东西，一言不合就让开发者自己$apply\n    +  删掉了ng-controller指令\n        \n        Controller终于和Component合体了\n    +  大幅度演进了脏值检测机制\n\n        双向绑定之所以能够工作，都是因为底层有脏值检测这么个神奇的东西，而实际上ng.1x里面的脏值检测机制的运行效率是非常差的，这就是为什么大家一直在吐槽绑定的对象不能太多、太深的原因。那么，在ng2中，大幅演进了这一机制，不仅引入了单向绑定，还引入了各种绑定策略，例如：只检测一次、利用jit动态生成脏值检测代码等等。毫无疑问，有了这些工具之后，数据绑定效率不再是问题。\n\n    +  嵌套路由问题\n\n        大家都知道，在ng1.x里面有个非常讨厌的问题，官方的路由机制是不能嵌套的，这就导致大家在开发的过程中不得不依赖第三方的ui-router.ng2中没有这个问题了，因为ng2的路由是基于Component的，天然就支持嵌套。\n    +  依赖注入机制改造\n    +  框架整体上基于Typescript开发， 这是最大的一个变更\n\n+ 2017.03 -- Angular4\n\n    支持向后兼容，优化视图引擎，剥离动画包，以及一些其他功能的改进\n    \n+ 2017.11 -- Angular5   只是遵循语义化版本号规范的正常迭代\n\n    + 构建优化\n    + 编译器改进, 改进了Angular编译器来支持增量编译,重新构建变得更快，特别是对生产环境的构建和AOT编译，增强的装饰器可以通过更精细化的去除空格来减小产生的包.   \n    + StaticInjector取代ReflectiveInjector依赖注入器,为了更多的减少polyfills，5.0中使用了StaticInjector注入器来替换原有的ReflectiveInjector注入器，这种注入器不再里来与ReflectPolyfill，可以大幅减少应用程序体积\n    + Zone执行速度的提升,5.0中默认提供的zones已经优化过，速度大幅提升，并且在应用程序中绕过zonee区域更加关于应用程序的性能。\n    + exportAs多命名支持, 5.0中提供了组件/指令的多命名支持，在对用户不修改代码情况下进行组件的迁移操作等非常有用，将一个组件导出多个名字，可以让组件已一个新名字来使用而达到不破坏现有代码的目的\n\n\n+ 2018.05 -- Angular6\n    Angular v6 新版本重点关注工具链以及工具链在 Angular 中的运行速度问题.Angular v6 是统一整体框架、Material 和 CLI 三大 Angular 组件的第一个版本，此次更新更多地关注于工具链上，以使其具有更好的可移植性。\n\n+ 2018.10 -- Angular7\n    \n    Angular7  这是跨整个平台的主要版本，包括核心框架，Angular Material和具有同步主要版本的CLI工具。\n\n+ 2019 - Angular8\n\n    作为一个期待已久的重大版本更新，Angular 8 为框架、Angular Material 和命令行界面工具 Angular CLI 带来了大量的改进和新功能。\n\n    +  默认启用差异化加载（Differential loading）\n    +  新的渲染引擎 Ivy, 作为新的渲染引擎，Ivy 旨在彻底缩减代码尺寸并增强系统灵活性。与目前的 Angular View Engine 相比，Ivy 具有以下优势：\n        \n        +  通过 Angular 编译器生成的代码更具可读性，更易调试\n        +  更快的构建速度\n        +  有效减少负载大小，浏览器用于下载和解析应用程序的时间将更短\n        +  更好的模板类型检查，以便在项目构建初期就可捕获更多 Bug\n        +  优秀的向后兼容性\n    + 使用动态导入进行路由配置,在 Angular 8 中，我们可以使用路由以延迟加载部分应用程序，这是通过在路由配置中使用 loadChildren 键来实现的。\n    + 对 Web Worker 的支持, 在 Angular 8 之前，使用 Web Worker 存在这样的问题：在 worker 中运行的代码不能与应用程序的其余部分位于同一 JavaScript 脚本文件中，它必须是分开的。因此，对于曾经希望借助 Angular CLI 等工具，自动将 JavaScript 文件拆分、绑定到更少文件夹下的效果往往不佳,\n        Angular 8 的新特性之一就是改进了使用 Angular CLI 捆绑 WebWorker 的支持，这项改进意味着我们将走向多并发、自动化的 Web Worker 之路。\n\n+ 2020 -- Angular9\n\n    这是涵盖整个平台的主要版本，包括框架，Angular Material和CLI。此版本默认情况下将应用程序切换到Ivy编译器和运行时，并引入了改进的组件测试方法\n    \n    + 默认使用 Ivy 编译器， Ivy 在 Angular8 时即可使用，但需要自行在 tsconfig.json 中增加配置以开启\n    + 更可靠的 ng update\n        \n        +  始终使用最新的 CLI。从 CLI 的 8.3.19 版本开始，我们现在在升级过程中使用了 TARGET 版本的 CLI。这意味着在未来，更新将始终由最新的 CLI 自动处理\n        + 进度更新更清晰。ng update 现在做了更多的工作来告诉你幕后的情况。对于每次迁移，你都会看到迁移中的更多信息。\n        + 更容易对更新进行调试。 默认情况下，ng update 运行所有迁移，并在磁盘上留下最终结果更改供你检查。版本 9 的更新还引入了新的 --create-commits 标志。当你运行 ng update --create-commits 时，该工具会在每个迁移动作后提交代码库的状态，这样你就可以逐步理解或调试我们对代码所做的更改。\n    \n    + providedIn 的新选项\n\n        当你在 Angular 中创建一个 @Injectable 服务时，你必须选择它应该添加到注入器的什么位置。除了以前的 root 和 module 这两种选项之外，还有两个新选项：\n\n        +  platform: 指定 providedIn: 'platform' 可以在一个特殊的单例平台注入器中使用该服务，该注入器由该页面上的所有应用共享。\n        + any: 在每个注入该令牌的模块（包括惰性加载模块）中提供一个唯一的实例\n\n    + TypeScript 3.7 支持\n        \n        Angular 已经更新，可以用 TypeScript 3.6 和 3.7 了，也包括 TypeScript 3.7 中非常受欢迎的可选串联（optional chaining）特性。为了与生态系统保持同步，还更新了其他生态系统依赖的版本，比如 Zone.JS 和 RxJS\n\n    + 移除 tslib 依赖项 ,Angular 现在不再依赖 tslib。在早期版本的 Angular 中它是必需的，并且是依赖项的一部分。如果你不用 Angular CLI，则可能需要安装这个包。\n\n\n+ 2020 --  Angular10\n\n    这是跨越整个平台（包括框架、Angular Material 和 CLI）的一次主要版本更新\n\n    [Angular 10正在接近终点线：带来哪些颠覆性变化](https://baijiahao.baidu.com/s?id=1673431402914533055&wfr=spider&for=pc)\n\n\n#### 第二步 全局看Angular应用架构设计\n\n##### 1. 组件设计-显示组件与功能组件\n\n\n\n","tags":["angular"],"categories":["angular"]},{"title":"git团队协作使用规范","url":"/blog/2020/03/10/git-standard/","content":"\n# 为了便于团队项目能够更好的协同开发和维护，现制定以下git使用规范\n\n## 1. 分支模型\n\n+ `master` - 最为稳定功能最为完整的随时可发布的代码;\n+ `dev` - 永远是功能最新最全的分支;\n+ `feature-[项目名称]` - 特性分支，某个功能点正在开发阶段的分支；\n+ `hotfix-[问题名称|bug编号]` - 修复线上代码的 bug的分支；\n\n### 1.1 master 主分支\n    \n+ master主分支始终保持稳定的可发布版本\n+ 只有项目组主程才拥有master主分支的管理权限（例如其他分支合并到master必须由主程操作）\n\n### 1.2 dev 开发分支\n+ dev开发分支为不稳定版本，可能存在功能缺失，但已有的功能必须是完整的\n+ 原则上不允许直接在dev分支上进行功能开发，必须新建feature分支进行开发\n+ dev分支是跑在测试环境的代码，给测试同学测试的\n\n### 1.3 feature-[功能名称] 功能开发分支\n+ 从master主干创建，横线后跟功能名称，用于新功能开发，每天下班前push提交到远程\n+ 开发完成之后切回dev分支，拉取最新dev上最新代码，把feature分支合并到dev分支，这里会有冲突文件，需要对应项目的同事一起来合并冲突\n\n### 1.4 hotfix-[问题名称 | bug编号] 紧急热修复分支\n+ 从master分支创建，横线后面跟上问题名称或者对应的bug编号，仅仅适用于**生产线问题紧急修复**！！！\n+ 修复完成，测试通过，合并到master和dev分支上，然后将此分支删除\n\n\n## 2. commit规范\n\n### 2.1 日志规范\n+ 功能点，列1，2，3\n+ 【研发：xx 测试：xx 项目经理：xxx】\n\n### 2.2 提交频率\n+ 每天下班前必须提交feature分支，并且push到远程【防止出现电脑挂掉导致代码遗失的问题】\n+ hotfix、feature分支尽量按照功能点或修复重构的问题及时commit（不要求push）【目的是防止一次commit提交大量改动，不便于后期排错】\n\n\n## 3. 开发流程\n1. 开发者pull master最新代码，拉取feature分支 统一命名风格：feature-[项目名称]\n2. 在feature分支上完成开发自测后，切换到dev分支，pull最新代码，把feature分支合并到dev分支，可能会出现冲突，和协作同事商量解决。\n\n    > 注意，非简单的解决featue a 和test分支冲突，需要商量是feature a还是feature b需要调整代码，假若feature a需要调整代码，feature a调整代码，合并到dev分支。feature b 重新操作合并到dev分支。\n\n3. 通知测试在测试分支测试，这个阶段不用关心发版进程，除非业务互相依赖。bug也在feature分支修改，修复完成后合并流程参考step2;\n4. 测试完全通过后，开发切换到master分支，pull最新代码，切换回feature分支，把master分支合并到feature分支（保证即将发布的代码没冲突），在gitlab提交合并请求，写上功能需求点，脚本等，指定项目管理员审核并且合并代码\n5. 管理员审核代码，处理（本次版本内）合并请求，打tag，发版，走线上验证流程。\n6. 完成功能开发。feature可以保留几周后统一清理\n\n\n## 4. 合并不同分支代码\n\n+ 保持commit记录清爽，比如上面的step2 ,把feature分支合并到dev分支，feature分支里面有很多每日的提交commit记录，这些记录只允许存在这个feature分支，不能合并到dev分支里面来\n\n`正确做法`\n``` bash\ngit merge --squash feature-a  \ngit commit -m \"合并feature-a分支代码到dev分支【研发：xxx 测试：xx 项目经理：xxx】\"\n```\n\n`错误做法`(这样会把feature分支上的提交记录都混过来，导致commit记录混乱，不方便回滚代码)\n```bash\ngit merge feature-a \n```\n\n\n#### git 提交合并请求，审核代码流程\n\n\n![合并请求](./git-standard/pull_request1.jpg)\n\n![创建合并请求](./git-standard/pull_request2.jpg)\n\n\n","tags":["团队规范","协同开发"],"categories":["项目总结"]},{"title":"angular相关知识分享","url":"/blog/2020/03/09/angular/","content":"\n### angular相关知识分享\n\n---\n\n#### resolve的使用\n\n##### 1、定义\n\n```js\n官方定义：一个接口，某些类可以实现它以扮演一个数据提供者\n解释：类似于路由前置钩子，可以在路由加载到新页面的时候，将数据提前获取到，从而解决加载新页面白屏的问题，当然也可以使用loading或者骨架屏之类的解决方案\n```\n\n##### 2、创建resolve\n\n> index-resolve.service.ts\n\n```js\nimport { Resolve } from '@angular/router';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n@Injectable(); // 表明将这个服务标记为可注入的\n// 导出一个实现resolve的类\nexport class IndexResolveService impolements Resolve<any> {\n  constructor(\n  \tprivate indexService: IndexService\n  ){}\n  // 必须声明resolve方法，返回一个Observable\n  resolve(): Observable<any>{\n    return this.indexService.getData();\n  }\n}\n```\n\n##### 3、使用\n\n> Index-routing.module.ts\n\n```js\nimport { IndexResolveService } from 'index-resolve.service.ts';\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nconst routes: Routes = [\n  {\n    path:'xxx',\n    component: 'xxx',\n    resolve: { indexData: IndexResolveService } // 在路由中定义resolve属性\n  }\n]\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule],\n  providers: [IndexResolveService] // 注入服务\n})\n```\n\n> Index.component.ts\n\n```js\nimport { ActivatedRoute } from '@angular/router';\nimport { OnInit } from '@angular/core';\nexport class IndexComponent implements OnInit {\n  constructor(\n  \tprivate route: ActivatedRoute // ActivatedRoute里面包含了路由的相关信息\n  ){}\n  ngOnInit(): void{\n    this.route.data.subscribe(res=>{\n\t\t\tconst data = res.indexData;\n    })\n  }\n}\n```\n\n##### 4、操作符\n\n- map\n  1. 定义\n\n  ```js\n  定义：将给定的project函数应用于源Observable发出的每个值，并将结果值作为Observable发出\n  解释：跟array的map类似，可以对里面的值进行操作，然后以Observable发射出去\n  ```\n  \n  2. 使用\n  \n  ```js\n  import { map } from 'rxjs/internal/operators';\n  this.indexService.getData().pipe(\n  \tmap((res)=>{\n      return xxx;\n    })\n  )\n  ```\n\n- forkJoin，zip\n\n  1. 定义\n\n  ```js\n  forkJoin定义：当所有可观测值完成时，从每个可观测值发出最后一个（最新）发出的值\n  解释：类似promise.all，当所有的Observable流结束后，发出每个流的最后一个发出的值\n  \n  zip定义：当每个传入的可观测值第一次完毕时，合并流然后发出去，当每个传入的可观测值第二次、第三次...完毕时，又分别合并发出去\n  解释：跟forkJoin一样都是合并流发出，但是zip会根据流本身发出的次数多次发出，而forkJoin仅发射最后一次\n  ```\n\n  2. 使用\n\n  ```js\n  import { forkJoin } from 'rxjs';\n  resolve(): Observable<any>{\n    return forkJoin([\n    \tthis.indexService.getData(),\n      this.indexService.getData1()\n    ])\n  }\n  ```\n\n- first，last，take\n\n  1. 定义\n\n  ```js\n  fitst定义：只发出由源Observable所发出的值中第一个（或第一个满足条件的值）\n  解释：在所有的流中取每个流第一次发出的值后结束\n  \n  last定义：只发出由源Observable所发出的值中最后一个\n  解释：在所有的流中取每个流最后一次发出的值后结束\n  \n  take定义：只发出由源Observable所发出的值中最初发出的n个值\n  解释：在所有的流中取每个流最初发出的n个值后结束\n  ```\n\n  2. 使用\n\n  ```js\n  import { first } from 'rxjs/internal/operators';\n  import { forkJoin } from 'rxjs';\n  resolve(): Observable<any>{\n    return forkJoin([\n    \tthis.indexService.getData(),\n      this.indexService.getData1()\n    ]).pipe(first())\n  }\n  ```\n\n  \n\n#### pipe的使用\n\n##### 1、创建pipe\n\n> index.pipe.ts\n\n```js\nimport { Pipe, PipeTransform } from '@angular/core';\n@Pipe({\n  name: 'index', // 管道名称\n  pure: true // 是否为纯管道，纯管道表示transform()方法只有在输入参数变化时才会调用，默认 true\n})\nexport class IndexPipe implements PipeTransform {\n  transform(value, name) {\n    // value: 需要转换的值\n    // name: 传入的参数\n    ...\n    return xxx;\n  }\n}\n// 定义多个管道\n@Pipe({})\nexport class ...\n```\n\n##### 2、使用\n\n> index.module.ts\n\n```js\nimport { IndexPipe } from 'index.pipe.ts';\n@NgModule({\n  declarations: [IndexPipe], // 声明管道\n  ...\n  exports: [IndexPipe] // 导出管道\n})\n```\n\n> index.component.html\n\n```html\n<div>\n  {{value | index : 'xxx'}}\n</div>\n```\n\n\n\n#### ngrx的使用\n\n##### 1、安装\n\n``` js\nnpm i @ngrx/store -S\nyarn add @ngrx/store\nng add @ngrx/store // 如果使用angular-cli 6+ ，可以直接在项目中添加\n```\n\n##### 2、创建动作action\n\n> animal.action.ts\n\n```js\nimport { createAction, props, Action } from '@ngrx/store';\nimport { Animal } from 'animal.model.ts'; // {name: string; age: number}\n// 方式A 8.x版本\nexport const CreateAnimal = createAction(\n\t'[CreateAnimal Page] CreateAnimal', // 通常[]里面声明使用动作的页面，后面声明触发动作的操作\n  props<{animal: Animal}>() \t\t\t\t\t// 定义动作接收的参数\n)\nexport const DeleteAnimal = createAction(\n\t'[DeleteAnimal Page] DeleteAnimal',\n  props<{animalLen: number}>()\n)\n\n// 方式B 7.x版本\nexport const ActionTypes = {\n  CREATE_ANIMAL: '[CreateAnimal Page] CreateAnimal',\n  DELETE_ANIMAL: '[DeleteAnimal Page] DeleteAnimal'\n}\nexport class CreateAnimal implememts Action {\n  readonly type = ActionTypes.CREATE_ANIMAL; // type用来描述发生了什么动作\n  public animal: Animal;\t\t\t\t\t\t\t\t\t\t // 定义动作接收的参数\n  constructor() {}\n}\nexport class DeleteAnimal implememts Action {\n  readonly type = ActionTypes.DELETE_ANIMAL;\n  public animalLen: number;\n  constructor() {}\n}\nexport type actions = CreateAnimal | DeleteAnimal; // 以别名的形式导出\n```\n\n##### 3、创建减速器reducer\n\n> animal.reducer.ts\n\n```js\nimport { createReducer } from '@ngrx/store';\nimport { CreateAnimal, DeleteAnimal } from 'animal.action.ts';\nimport { Animal } from 'animal.model.ts'; // {name: string; age: number}\nimport * as AnimalActions from 'animal.action.ts';\n\nconst initData: Animal = {\n  name: 'pig',\n  age: 12\n}\n// 方式A\nconst _animalReducer = createReducer(\n  \t[initData],\n    on(CreateAnimal, (state: Animal[], { animal }) => ([...state, animal])),\n    on(DeleteAnimal, (state: Animal[], { animalLen }) => {\n      state.splice(animalLen, 1)\n      return state;\n    }\n  )\nexport function animalReducer(state, action){\n  return _animalReducer(state, action);\n}\n\n// 方式B\nexport function animalReducer(state: Animal[] = [initData], action: AnimalActions.actions){\n  switch(action.type){\n    case AnimalActions.ActionTypes.CREATE_ANIMAL:\n      return [...state, action.animal];\n    case AnimalActions.ActionTypes.DELETE_ANIMAL:\n      state.splice(action.animalLen, 1);\n      return state;\n    default:\n      return state;\n  }\n}\n```\n\n##### 4、创建state\n\n> animal.state.ts\n\n```js\nimport { Animal } from 'animal.model.ts'; // {name: string; age: number}\nexport interface AnimalState {\n  readonly animal: Animal[];\n}\n```\n\n##### 5、使用\n\n> app.module.ts\n\n```js\nimport { NgModule } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { animalReducer } from 'animal.reducer.ts';\n\n// StoreModule.forRoot({})用户全局注册\n@NgModule({\n  imports: [\n    StoreModule.forRoot({ animal: animalReducer })\n  ],\n})\nexport class AppModule {}\n```\n\n> create.component.ts\n\n```js\nimport { Obserbable } from 'rxjs';\nimport { OnInit } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { Animal } from 'animal.model.ts'; // {name: string; age: number}\nimport { AnimalState } from 'animal.state.ts';\nimport * as AnimalActions from 'animal.action.ts';\nexport class CreateAnimalComponent implements OnInit {\n  animal: Observable<Animal[]>;\n  constructor(\n  \tprivate store: Store<AnimalState>\n  ){\n    this.animal = store.select('animal');\n  }\n\tcreateAnimal(){\n    // 以函数形式定义带的动作用法 方式A\n    this.store.dispatch(CreateAnimal({\n      name: 'cat',\n      age: 12\n    }))\n    // 以class形式定义的动作用法 方式B\n    this.store.dispatch(new AnimalActions.CreateAnimal({\n      name: 'cat',\n      age: 12\n    }))\n  }\n}\n```\n\n","tags":["angular"],"categories":["angular"]},{"title":"node-schedule定时任务","url":"/blog/2019/12/11/node-schedule/","content":"\n### 内容概要\n- 在实际开发项目中，会遇到很多定时任务的工作。比如：定时发送推送通知，定时更新某些数据等等\n这是我们第一时间想到的就是可以写个定时器，来完成相应的需求，而在在node.js中可以使用node-schedule来完成定时任务\nnestjs是一个node框架当然也可以使用node-schedule来完成定时任务。下面就用示例来说明一下node-schedule的用法.\n\n安装依赖\n    npm install node-schedule\n\n### 开启一个定时任务\n```js\nconst schedule = require('node-schedule');\n\nfunction scheduleTask(){\n    schedule.scheduleJob('30 * * * * *', ()=>{\n        console.log('scheduleTask:' + new Date());\n    }); \n}\n\nscheduleTask();\n// schedule.scheduleJob的回调函数中写入要执行的任务代码，一个定时器就完成了！传入的'30 * * * * *'带来的结果是每分钟的30秒时都会执行\n```\n\n### 定时任务中的通配符解释\n    * * * * * *\n    ┬ ┬ ┬ ┬ ┬ ┬\n    │ │ │ │ │  |\n    │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)\n    │ │ │ │ └───── month (1 - 12)\n    │ │ │ └────────── day of month (1 - 31)\n    │ │ └─────────────── hour (0 - 23)\n    │ └──────────────────── minute (0 - 59)\n    └───────────────────────── second (0 - 59, OPTIONAL)\n\n6个占位符从左到右分别代表：秒、分、时、日、月、周几\n\n每分钟的第30秒触发： '30 * * * * *'\n\n每小时的1分30秒触发 ：'30 1 * * * *'\n\n每天的凌晨1点1分30秒触发 ：'30 1 1 * * *'\n\n每月的1日1点1分30秒触发 ：'30 1 1 1 * *'\n\n每年的1月1日1点1分30秒触发 ：'30 1 1 1 1 *'\n\n每周1的1点1分30秒触发 ：'30 1 1 * * 1'\n\n### 范围触发\n\n```js\nconst schedule = require('node-schedule');\n\nfunction scheduleTask(){\n    schedule.scheduleJob('1-10 * * * * *', function(){\n        console.log('scheduleTask:' + new Date());\n    }); \n}\n\nscheduleTask();\n// 每分钟的1-10秒都会触发  其它占用符使用方法一样\n```\n\n### 递归规则定时器\n\n```js\nconst schedule = require('node-schedule');\n\nfunction scheduleTask(){\n\n    let rule = new schedule.RecurrenceRule();\n    // rule.dayOfWeek = 2;\n    // rule.year = 2020; \n    // rule.month = 3;\n    // rule.dayOfMonth = 1;\n    // rule.hour = 1;\n    // rule.minute = 30;\n    rule.second = 0;\n    \n    schedule.scheduleJob(rule, function(){\n       console.log('scheduleTask:' + new Date());\n    });\n   \n}\n\nscheduleTask();\n// 每分钟第60(0)秒时就会触发\n```\n\n### 对象文本语法定时器\n```js\nconst schedule = require('node-schedule');\n\nfunction scheduleTask(){\n    //dayOfWeek\n    //month\n    //dayOfMonth\n    //hour\n    //minute\n    //second\n    schedule.scheduleJob({hour: 17, minute: 0, dayOfWeek: 5}, function(){\n        console.log('scheduleTask:' + new Date());\n    });\n   \n}\n\nscheduleTask();\n// 每周五的下午17：00分触发\n```\n### 取消定时器\n调用定时器对象的cancl方法即可\n```js\nconst schedule = require('node-schedule');\n\nfunction scheduleCancel(){\n\n    let counter = 1;\n    const j = schedule.scheduleJob('* * * * * *', function(){\n        \n        console.log('定时器触发次数：' + counter);\n        counter++;\n        \n    });\n\n    setTimeout(function() {\n        console.log('定时器取消')\n        j.cancel();   \n    }, 5000);\n}\n\nscheduleCancel();\n// 5000ms后取消则触发五次后将会取消\n```\n\n### nestjs中使用定时器\n这里有这样一个需求，每周五的下午6点定时更新数据库中某些字段；\n这里我们就可以实现一个接口用来更新数据库表字段，而关键就在于每周五的下午6点去更新，这时我们就可以启一个定时任务，定时调用接口达到定时更新的目的。\n例如：\n有接口 http://localhost:3000/photo/updateStatus 定时将数据库中数据删除(不建议删库，一般设置字段表示数据状态，更新该字段为指定值表示删除状态)\n\n在main.ts引入并使用\n```ts\nimport { Logger } from '@nestjs/common';\nimport { NestFactory, FastifyAdapter } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport * as cors from 'cors';\nimport { join } from 'path';\nimport fly from 'flyio';\n\n// tslint:disable-next-line:no-var-requires\nconst schedule = require('node-schedule');\n\nfunction scheduleTask() { // 定时任务\n    const timing = schedule.scheduleJob('0 0 0 * * *', () => {\n        Logger.log('定时任务');\n        fly.get('http://localhost:3000/photo/updateStatus').then(res => {\n            Logger.log(JSON.stringify(res.data));\n        }).catch(err => {\n            Logger.log(JSON.stringify(err));\n        }); // 定时任务更改数据\n    });\n}\nscheduleTask(); // 开启定时任务\n\nasync function bootstrap() {\n    const app = await NestFactory.create(AppModule);\n    app.useStaticAssets(join(__dirname, '..', 'public'));\n    app.use(\n        cors({\n            credentials: true,\n        }),\n    );\n    await app.listen(3000);\n}\nbootstrap();\n```\n\n### nest-schedule\n[nest-schedule](http://npm.taobao.org/package/nest-schedule)是一个基于node-schedule实现的用于nest.js的任务库\n...还未尝试使用\n\n","tags":["Nest.js","入门实战-定时任务"],"categories":["nestjs"]},{"title":"Nest.js项目入门实战(一)","url":"/blog/2019/12/10/nest-one/","content":"\n### 内容概要\n- 该篇主要介绍Nest.js项目的基础知识以及项目初始搭建,nest cli的使用,以及连接数据库实现一个简单的增删改查接口的项目示例\n\n### Nest.js简介\nNest是一套现代化的基于Node.js的强大的Web应用框架\n\nNest的核心概念是提供一种体系结构，它帮助开发人员实现层的最大分离，并在应用程序中增加抽象\n\n>文档：https://nestjs.com/\n>中文文档：https://docs.nestjs.cn/\n>git地址：https://github.com/nestjs/nest\n\n---\n\n### 使用Nest CLI创建项目\n\n安装CLI &nbsp;&nbsp;&nbsp; `npm i -g @nestjs/cli`\n使用CLI新建项目 &nbsp;&nbsp;&nbsp; `nest new project-name`\n\n运行后会默认创建以下内容\n\n\tCREATE /nest-test-peoject/.prettierrc (51 bytes)\n\tCREATE /nest-test-peoject/nest-cli.json (64 bytes)\n\tCREATE /nest-test-peoject/package.json (1700 bytes)\n\tCREATE /nest-test-peoject/README.md (3370 bytes)\n\tCREATE /nest-test-peoject/tsconfig.build.json (97 bytes)\n\tCREATE /nest-test-peoject/tsconfig.json (336 bytes)\n\tCREATE /nest-test-peoject/tslint.json (426 bytes)\n\tCREATE /nest-test-peoject/src/app.controller.spec.ts (617 bytes)\n\tCREATE /nest-test-peoject/src/app.controller.ts (274 bytes)\n\tCREATE /nest-test-peoject/src/app.module.ts (249 bytes)\n\tCREATE /nest-test-peoject/src/app.service.ts (142 bytes)\n\tCREATE /nest-test-peoject/src/main.ts (208 bytes)\n\tCREATE /nest-test-peoject/test/app.e2e-spec.ts (561 bytes)\n\tCREATE /nest-test-peoject/test/jest-e2e.json (183 bytes)\n\n\n这里为我们创建了一个根模块AppModule &nbsp;&nbsp;&nbsp; `main.ts`为项目启动入口文件\n\n###  Nest项目-基础知识\n\n- 模块Module \n    用于将代码拆分为独立的和可重用的模块，例如有一个用户信息模块，然后将该用户模块的控制器和服务集合进来，最后需要将用户模块导入到根Module使用。\n每个Nest应用都有一个根模块，通常是 AppModule。根模块提供了用来启动应用的引导机制，可以包含很多功能模块。\n<br />\n\n\t**Module模块中@Module()装饰器接受一个对象**\n\t属性|描述\n\t---|:--:|\n\tproviders|由nest注入器实例化的服务，可以在这个模块之间共享\n\tcontroller|存放创建的一组控制器\n\timports|导入此模块中所需的提供程序的模块列表\n\texports|导出这个模块可以其他模块享用providers里的服务\n\n- 控制器Controller\n\t通俗来说就是路由Router，负责处理客户端传入的请求参数并向客户端返回响应数据，也可以理解是HTTP请求。nest.js提供许多http请求的装饰器，例如:方法参数装饰器@Param,@Body(),@Query;方法装饰器@Post(),@Get,@Put()等。\n\n- 服务与依赖注入 Provider & Dependency injection\n    在这里处理所有请求执行逻辑，在控制器中通过constructor函数以依赖注入的方式实现。Controller负责处理Request及产生Response，而数据库存取或是业务逻辑通常写在Service class里。\n\t提供程序是 Nest的一个基本概念。许多基本的 Nest类可能被视为提供者 - service,repository, factory 等等。 他们都可以通过 constructor 注入依赖关系。 这意味着对象可以彼此创建各种关系，并且“连接”对象实例的功能在很大程度上可以委托给 Nest运行时系统。 提供者只是一个用 @Injectable()装饰器注释的类。\n\n- Middleware 中间件\n\t中间件是在路由处理程序之前调用的函数。中间件功能可以访问请求和响应对象，以及应用程序请求-响应周期中的下一个中间件功能。\n\t中间件函数可以执行以下任务:\n\t- 执行任何代码。\n\t- 对请求和响应对象进行更改。\n\t- 结束请求-响应周期。\n\t- 调用堆栈中的下一个中间件函数。\n\t- 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。\n\n- Exception filter 过滤器\n\tNest 内置了全局异常处理层，一旦应用程序抛出异常，Nest 便会自动捕获这些异常并给出 JSON 形式的响应。\n\t未知类型的错误将会抛出以下错误\n\t```\n\t{\n\t\t\"statusCode\": 500,\n\t\t\"message\": \"Internal server error\"\n\t}```\n- Pipe 管道\n\t管道是具有 @Injectable() 装饰器的类。管道应实现 PipeTransform 接口。\n\t管道有两个类型:\n\t转换：管道将输入数据转换为所需的数据输出\n\t验证：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常;\n- Guard 守卫\n\t守卫可以做权限认证，如果你没有权限可以拒绝你访问这个路由，默认返回403错误\n\t守卫是用@Injectable()装饰器注释的类。应该实现CanActivate接口，具体代码在canActivate方法实现，返回一个布尔值，true就表示有权限，false抛出异常403错误。\n\t使用：\n\t直接@UseGuards()装饰器里面使用，作用当前控制器路由所有的请求参数 从 @nestjs/common 包导入。\n\t在全局注册使用内置实例方法useGlobalGuards，作用整个项目。\n\t```\n\tconst app = await NestFactory.create(AppModule);\n\tapp.useGlobalGuards(new Guard());\n\t```\n- Interceptor 拦截器\n\t拦截器可以做很多功能，比如缓存处理，响应数据转换，异常捕获转换，响应超时跑错，打印请求响应日志。\n\t设置拦截器：为了设置拦截器, 我们使用从 @nestjs/common 包导入的 @UseInterceptors() 装饰器。与守卫一样, 拦截器可以是控制器范围内的, 方法范围内的或者全局范围内的。\n\n<font color='red'> 以上内容nestjs文档都有详细描述具体可以[前往阅读](https://docs.nestjs.cn/)</font>\n\n###  Nest项目-连接数据库\n\n- Nest 与数据库无关，可以轻松地与任何 SQL 或 NoSQL 数据库集成。我们可以直接使用任何通用的 Node.js 数据库集成库或 ORM ，例如 [Sequelize (recipe)](https://sequelize.org/),[TypeORM](https://typeorm.io/#/) ，以在更高的抽象级别上进行操作。Nest 使用TypeORM是因为它是 TypeScript 中最成熟的对象关系映射器( ORM )。因为它是用 TypeScript 编写的，所以可以很好地与 Nest 框架集成。这里我们连接操作mysql数据库。\n安装typeorm 和 mysql  `npm install --save @nestjs/typeorm typeorm mysql`\n将`TypeOrmModule`导入`AppModule`。\n\n```ts\n\timport { Module } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\n\t@Module({\n\timports: [\n\t\tTypeOrmModule.forRoot({\n\t\ttype: 'mysql', // 数据库类型。你必须指定要使用的数据库引擎。该值可以是\"mysql\"，\"postgres\"，\"mariadb\"，\"sqlite\"，\"cordova\"，\"nativescript\"，\"oracle\"，\"mssql\"，\"mongodb\"，\"sqljs\"，\"react-native\"。此选项是必需的。\n\t\tname:'', // 连接名。 在使用 getConnection(name: string) 或 ConnectionManager.get(name: string)时候需要用到。不同连接的连接名称不能相同，它们都必须是唯一的。如果没有给出连接名称，那么它将被设置为\"default\"。\n\t\thost: 'localhost', // 数据库 host\n\t\tport: 3306, // 数据库端口。mysql 默认的端口是3306.\n\t\tusername: 'root', // 数据库用户名\n\t\tpassword: 'root', // 数据库密码\n\t\tdatabase: 'test', // 数据库名\n\t\tentities: [],//  要加载并用于此连接的实体。接受要加载的实体类和目录路径。目录支持 glob 模式。示例：entities: [ \"entity/*.js\", \"modules/**/entity/*.js\"]。\n\t\tsynchronize: true,// 指示是否在每次应用程序启动时自动创建数据库架构。 请注意此选项，不要在生产环境中使用它，否则将丢失所有生产数据。但是此选项在调试和开发期间非常有用。\n\t\tcharset:'utf8mb4', // 连接的字符集\n\t\ttimezone: '+0800', // MySQL 服务器上配置的时区。这用于将服务器日期/时间值强制转换为 JavaScript Date 对象\n\t\tlogging: true, // 指示是否启用日志记录。如果设置为true，则将启用查询和错误日志记录。\n\t\tconnectTimeout:'10000', // 在连接到 MySQL 服务器期间发生超时之前的毫秒数。 （默认值：10000）\n\t\t...\n\t\t}),\n\t],\n\t})\n\texport class AppModule {}\n```\nforRoot() 方法接受与来自 TypeORM包的 createConnection() 相同的配置对象。另外，我们可以创建 ormconfig.json ，而不是将配置对象传递给 forRoot()。\n一旦完成，TypeORM 连接和 EntityManager 对象就可以在整个项目中注入(不需要导入任何模块)\n\n- 存储库模式\n\tTypeORM 支持存储库设计模式，因此每个实体都有自己的存储库。可以从数据库连接获得这些存储库。\n\t需要使用官方TypeORM文档中的  entity 实体\n\n###  Nest项目-创建一个PhotoModule\n上面已经在AppModule注入了TypeOrmModule并配置数据库信息，现在我们配置TypeOrmModule.forRoot()中的entities为(glob 模式匹配目录文件)\n\n\tentities:[__dirname + '/**/*.entity{.ts,.js}']\n\n方便我们在文件中创建entity文件，其中`__dirname` 表示的是当前文件所在目录  `**`匹配任意数量的字符包括空字符和路径分隔符 `*`匹配任意数量的字符包括空字符\n接下来使用`nest g mo photo`创建PhotoModule，该命令将在src目录下创建了photo文件目录并新建了PhotoModule文件自动注入到了AppModule\n\n\tnest g mo photo\n\tCREATE /src/photo/photo.module.ts (82 bytes)\n\tUPDATE /src/app.module.ts (1359 bytes)\n\n创建完成后AppModule如下\n```ts\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { Connection } from 'typeorm';\t\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { PhotoModule } from './photo/photo.module';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n        type: 'mysql',\n        host: '192.168.1.6',\n        port: 3306,\n        username: 'root',\n        password: 'xxxx',\n        database: 'xxxx',\n        entities: [__dirname + '/**/*.entity{.ts,.js}'],\n        synchronize: true,\n        timezone: '+0800',\n        logging: true,\n    }),\n    PhotoModule,\n  ],\n  controllers: [AppController],\n  providers: [\n      AppService\n    ],\n})\nexport class AppModule {\n\tconstructor(private readonly connection: Connection) { }\n}\n```\n接下来我们依次创建PhotoController和PhotoService\n\n\tnest g co photo\n\tCREATE /src/photo/photo.controller.spec.ts (486 bytes)\n\tCREATE /src/photo/photo.controller.ts (99 bytes)\n\tUPDATE /src/photo/photo.module.ts (170 bytes)\n\n\tnest g s photo\n\tCREATE /src/photo/photo.service.spec.ts (453 bytes)\n\tCREATE /src/photo/photo.service.ts (89 bytes)\n\tUPDATE /src/photo/photo.module.ts (247 bytes)\n\n一般的我们将entity文件放在他们的域中, 放在相应的模块目录中。当然也可以在src目录下新建entities目录将entity文件放在该目录下管理。\n\n- 创建photo实体(photo.entity.ts)\n实体是一个映射到数据库表（或使用 MongoDB 时的集合）的类。 你可以通过定义一个新类来创建一个实体，并用@Entity()来标记：\n```ts\n\timport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n\t@Entity('photo') // 实体名称 对应数据库表名\n\texport class Photo {\n\t@PrimaryGeneratedColumn({comment: '照片表'})\n\tid: number;\n\n\t@Column({ nullable: true, length: 30, comment: '照片名称' })\n\tname: string;\n\n\t@Column({ nullable: false, default:0, comment: '该条记录状态 0正常 1删除' })\n\tstatus: number;\n\n\t@Column({ nullable: true, type: 'datetime', comment: '该条记录创建时间' })\n\tcreate_time: string;\n\n\t@Column({ nullable: true, length: 255, comment: '照片资源链接' })\n\turl: string;\n\t}\n\n\t// orm配置中若synchronize为true则会在数据库自动执行创建表sql 创建photo表\n\tCREATE TABLE `photo` (\n\t\t`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '照片表',\n\t\t`name` varchar(30) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '照片名称',\n\t\t`status` int(11) NOT NULL DEFAULT '0' COMMENT '该条记录状态 0正常 1删除',\n\t\t`create_time` datetime DEFAULT NULL COMMENT '该条记录创建时间',\n\t\t`url` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '照片资源链接',\n\t\tPRIMARY KEY (`id`)\n\t) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n```\n\n<font color='red'> synchronize: true,指示是否在每次应用程序启动时自动创建数据库架构。 \n请注意此选项，不要在生产环境中使用它，否则将丢失所有生产数据。但是此选项在调试和开发期间非常有用。</font>\n\n[实体列属性等相关配置具体可参考typeOrm中实体](https://typeorm.io/#/entities)\n\n###  Nest项目-PhotoController和PhotoService\n接下来我们在PhotoController中创建几个方法用来接收客户端传入的请求参数并向客户端返回响应数据\n```ts\nimport { Controller, Get, Post, Patch, Body, Query } from '@nestjs/common';\nimport { PhotoService } from './photo.service';\n\n@Controller('photo')\nexport class PhotoController {\n    // 宣告变量，型別为PhotoService\n    // private readonly photoService:PhotoService;\n    // 建立PhotoController实例，一并建立PhotoService实例\n    // constructor() { this.photoService= new PhotoService(); } \n    constructor(private readonly photoService: PhotoService) { } // 将PhotoService注入到PhotoController\n\n    /**\n     * 创建相片记录\n     * @param body\n     */\n    @Post() // 请求方法装饰器\n    async createPhoto(@Body() body): Promise<any> {\n        return await this.photoService.createPhoto(body);\n    }\n\n    /**\n     * 删除相片记录\n     * @param body\n     */\n    @Patch()\n    async deletePhoto(@Body() body): Promise<any> {\n        return await this.photoService.deletePhoto(body);\n    }\n\n    /**\n     * 编辑相片记录内容\n     * @param body\n     */\n    @Patch()\n    async updatePhoto(@Body() body): Promise<any> {\n        return await this.photoService.updatePhoto(body);\n    }\n\n    /**\n     * 获取相片列表\n     * @param query\n     */\n    @Get()\n    async getPhotos(@Query() query): Promise<any> {\n        return await this.photoService.getPhotos(query);\n    }\n}\n```\n对应的 我们需要在PhotoService中写上对应的方法处理所有请求执行逻辑\n\n```ts\nimport { Injectable } from '@nestjs/common';\nimport { Photo } from '../entities/photo.entity'; // 引入实体文件\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, getRepository } from 'typeorm';\n\n@Injectable()\nexport class PhotoService {\n    constructor(\n        @InjectRepository(Photo)\n        private readonly photoRepository: Repository<Photo>, // Photo存储库\n    ) { }\n\n    /**\n     * 创建相片记录\n     * @param body\n     */\n    async createPhoto(body): Promise<any> {\n        const newPhoto = new Photo();\n        newPhoto.create_time = body.create_time;\n        newPhoto.name = body.name;\n        // newPhoto.status = body.status;\n        newPhoto.url = body.url;\n        const newOrderRes = await this.photoRepository.save(newPhoto);\n        return { message: '创建成功', code: '01', content: newOrderRes };\n    }\n\n    /**\n     * 删除相片记录\n     * @param body\n     */\n    async deletePhoto(body): Promise<any> {\n        // await this.photoRepository.delete(body.id);\n        // await this.photoRepository.delete( { name:body.name});\n        const needDelete = await this.photoRepository.findOne(body.id);\n        await getRepository(Photo)\n            .createQueryBuilder('Photo')\n            .update(needDelete)\n            .where('id = :id', { id: body.id })\n            .set({ status: 1 })\n            .execute();\n            return { message: '删除成功', code: '01' };\n    }\n\n    /**\n     * 编辑相片记录内容\n     * @param body\n     */\n    async updatePhoto(body): Promise<any> {\n        const needUpdate = await this.photoRepository.findOne(body.id);\n        const updated = Object.assign(needUpdate, body);\n        await this.photoRepository.update(body.id,updated);\n    }\n\n    /**\n     * 获取相片列表\n     * @param query\n     */\n    async getPhotos(query): Promise<any> {\n        const qb = await getRepository(Photo)\n            .createQueryBuilder('p')\n            // .select('p')\n            .select(['p.name','p.url'])\n            .skip((query.page - 1) * query.size)\n            .take(query.size)\n            .orderBy({\n                'p.create_time': 'DESC',\n            });\n        qb.where('1 = 1');\n        if ('name' in query) {\n            qb.andWhere('p.name = :name', { name: query.name });\n        }\n        qb.andWhere('p.status != 1 ');\n        const list = await qb.getMany();\n        const total = await qb.getCount();\n        return { list, total, message: '请求列表成功', code: '01' };\n\t\t\n    }\n}\n```\n在photoModule中\n```ts\nimport { Module } from '@nestjs/common';\nimport { PhotoController } from './photo.controller';\nimport { PhotoService } from './photo.service';\nimport { Photo } from '../entities/photo.entity';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([Photo])], // 使用forFeature()方法来定义应在当前范围中注册的存储库。\n  controllers: [PhotoController],\n  providers: [PhotoService]\n})\nexport class PhotoModule {}\n```\n到这里一个PhotoModule模块就完成啦\n\n使用`npm run start` 启动项目通过postman传入参数请求到 http://localhost/photo 就可以访问接口完成增删改查\n\n### PhotoService中处理数据\n在PhotoService中处理数据时用到了typeorm的api\n- Repository ，Query Builder\n\t通过`this.photoRepository` `getRepository().createQueryBuilder()` `getConnection().createQueryBuilder()` 都可以操作想要操作的存储库\n\n### 未完待续..\n\n","tags":["Nest.js","入门实战"],"categories":["nestjs"]},{"title":"js的一些常用简写操作","url":"/blog/2019/12/10/js-abbreviation/","content":"\n### 内容概要\n有助于大家更加熟练的运用 JavaScript 语言来进行开发工作 -- 关于简写 大家一起慢慢补充0_0哦\n\n### 声明变量\n```js\n//在函数开始之前，对变量进行赋值是一种很好的习惯。在申明多个变量时,我们可能会：\nlet x;\nlet y;\nlet z = 3;\n\n// 简写为\nlet x, y, z=3;\n```\n### 三目运算符\n```js\n// 通常我们经常会写if...else..语句 例如\nvar a = 0;\nvar b;\nif (a > 10) {\n    b = 'greater than 10';\n} else {\n    b = 'less than 10';\n}\n// 可简写为\nvar b = a > 10 ? 'greater than 10' : 'less than 10';\n```\n### if 语句\n```js\n// 在使用 if 进行基本判断时，可以省略赋值运算符。\nif (a === true) / if (a === undefined || a === null || a === '' || a===0) \n// 可简写为\nif( a ) / if(!a)\n......\n```\n### 十进制数\n```js\n// 可以使用科学计数法来代替较大的数据，如可以将 100000 简写为 1e5。\nlet a = 100000;\n// 可简写为\nlet a = 1e5;\n```\n### 模板字符串\n\n```js\n// 过去我们习惯了使用“+”将多个变量转换为字符串\nconst url = 'http://' + host + ':' + port + '/' + path;\n// ES6 提供了相应的方法，我们可以使用反引号和 $ { } 将变量合成一个字符串。\nconst url = `http://${host}:${port}/${path}`;\n```\n\n### 未完待续，大家快来补充啊...\n\n\n\n\n\n","tags":["js"],"categories":["项目总结"]},{"title":"es6内容解读","url":"/blog/2019/11/29/js-es6/","content":"\n### 赋值解构\n\n- 赋值解构使得声明变量更简洁。特点是左边多个变量，右边是一个对象或数组。\n\n\n```js\n// 解构出对象的属性\nlet aa = {b: '11', c:'22'};\nlet {b,c} = aa;\nconsole.log(b,c);\t// 11 22\n```\n\n```js\n// 解构出对象的属性并重新取名\nlet a = {b: '11', c:'22'};\nlet {b: bb,c: cc} = aa;\nconsole.log(bb,cc);\t// 11 22\n```\n\n```js\n// 解构数组\nlet [a, b] = [1, 2, 3];\nconsole.log(a,b);\t// 1 2\n```\n\n```js\n// 解构时给变量默认值\n[a=5, b=7] = [1];\nconsole.log(a,b);\t// 1 7\n```\n\n```js\n// 解构 rest的使用。...能解构剩余属性值\n[a, b, ...rest] = [10, 20, 30, 40, 50];\nconsole.log(a,b,rest);\t// 10 20 [30, 40, 50]\n({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});\nconsole.log(a,b,rest);\t// 10 20 {c: 30, d: 40}\n```\n\n### Generator生成器\n\n- 可以理解为一个状态机，封装了多个内部状态，每次调用就遍历并执行一个状态。这样就可以使得多个函数共同配合完成某个任务。\n\n\n```js\nfunction* helloWorldGenerator() {\n  yield 'hello';\t\n  yield 'world';\n  return 'ending';\t// 以return作为结束执行的标志\n}\nvar hw = helloWorldGenerator();\nhw.next();\t// 执行后的数据为一个对象：{ value: 'hello', done: false }\nhw.next();\t// { value: 'world', done: false }\nhw.next();\t// { value: 'ending', done: true }\nhw.next();\t// { value: undefined, done: true }\n\n// 也可以直接return 不必一直调用next() \nhw.return('aaa');\t// { value: 'aaa', done: true }\n\n// yield* fn() 这种用法表示generator的嵌套执行\n```\n\n- Generator可以作为一个暂缓执行函数\n\n\n```js\nfunction* f() {\n  console.log('执行了！')\n}\n\nvar generator = f();\t// 如果这里的f()是普通函数，那么这里就执行了f()里面的内容\n\nsetTimeout(function () {\n  generator.next()\n}, 2000);\n```\n\n- Generator有3个方法 next()  throw()  return()。它们将yield替换成值、throw语句、return语句。next里面传值时会被当做上一个yield的值\n\n- Generator轻松遍历所以数组成员\n\n```js\nfunction* iterTree(tree) {\n  if (Array.isArray(tree)) {\t// 如果是Array\n    for(let i=0; i < tree.length; i++) {\n      yield* iterTree(tree[i]);\t// 将Array的每一项当参数继续传入函数执行\n    }\n  } else {\t// 否则直接返回\n    yield tree;\n  }\n}\nconst tree = [ 'a', [[1, 2, 3],'b', 'c']];\nfor(let x of iterTree(tree)) {\t// for of 能循环执行yield\n  console.log(x);\t// a 1 2 3 b c\n}\n```\n\n- Generator实现协程。A B两个方法交替执行完成同一个任务\n\n```js\n// A函数\nfunction* A(){\n  console.log(\"1\");\n  yield \"B\";//交由B处理\n  console.log(\"11\");\n  yield \"B\";//交由B处理\n}\n// B函数\nfunction* B(){\n   console.log(\"2\");\n   yield \"A\";//交由A处理\n   console.log(\"22\");\n   yield \"A\";//交由A处理\n   console.log(\"222\");//上菜\n}\nvar fnA = A();\nvar fnB = B();\n//流程控制\nfunction run(fn){\n   var v = fn.next();\n   if(v.value ==\"A\"){\n      run(fnA);\t// 当函数返回值是A 再次进入run 达到循环调用的目的\n   }else if(v.value ==\"B\"){\n      run(fnB);\n   }\n}\nrun(fnB);//开始执行 2 1 22 11 222\n```\n\n- 生成器本身带有Symbol.iterator。Symbol：唯一标识id，iterator：生成器\n\n### 监听对象属性变化\n\n- **Object.defineProperty**通过监听对象属性的读取和修改触发函数执行业务代码\n\n```js\n let obj = {\n    _hello:'hello world' //表示私有变量\n};\nObject.defineProperty(obj,'hello',{\n    get() {\n        console.log('get');\n        return this._hello;\t// 这里会返回一个值修改obj的hello属性\n    },\n    set:function (value) {\n        console.log('set');\n        this._hello = value; // 使得obj的私有属性_hello与hello属性保持一致\n    }\n});\nconsole.log(obj.hello);\nobj.hello = 'goodbye';\nconsole.log(obj.hello);\n```\n\n- 代理**Proxy**类似于defineProperty的加强版\n\n```js\nlet obj = {\n     hello:'hello world'\n };\nlet proxy = new Proxy(obj, {\n    get(target, property) {\n        console.log('get');\n        return target[property];\n    },\n    set(target,property,value) { // target当前对象 property属性 value修改的属性值\n        console.log('set');\n        target[property] = value;\n    }\n});\nconsole.log(proxy.hello);\nproxy.hello = 'goodbye';\nconsole.log(proxy.hello);\n```\n\n### async await的用法\n\nasync和await配合使用常用来解决回调地狱的问题，可以使代码更简洁\n\n```js\n\nfunction takeLongTime() {\t// 返回一个promise对象\n    return new Promise(resolve => {\n        setTimeout(() => resolve(\"long_time_value\"), 1000);//这里用定时器模拟异步操作\n    });\n}\nasync function test() {\t\t// async申明的函数本质上是一个promise对象\n    const v = await takeLongTime();\n    console.log(v);\t// 只有等待takeLongTime()执行完才打印信息，在此函数体内就把异步操作变同步了\n}\ntest();\n```\n\n异步操作结束->通知到resolve()函数->通知到await可以执行下面代码了。用generate生成器也可以做到这一点。\n\n### call、apply、bind的区别\n\n每个函数都包含这3个方法，它们能修改this的指向\n\n```js\nvar a = {\n    user:\"Ice\",\n    fn:function(e,ee){\n        console.log(this.user); //Ice\n\t\tconsole.log(e+ee);\n    }\n}\nvar b = a.fn; // 申明变量b继承变量a的一个方法\nb(1, 2);  // underfined NaN b继承了a的方法但是它的this指向的是全局变量\nb.call(a,1,2); // call使b的this指向了a\nb.apply(a,[1,2]); // 同上，区别在于传参不同\nb.bind(a);\t// 这里 bind返回了一个新的函数，这里并不会立即执行\n```\n\n### for...in和for...of\n\nfor循环相比于用api循环的优点在于可以主动用break结束循环，用return结束函数。\n\n```js\n// for in遍历对象\nvar obj = {a:1, b:2, c:3};\nfor (var prop in obj) {\n  console.log(prop);\t// a b c\n}\n// for in遍历数组\nvar obj = ['a', 'b', 'c'];\nfor (var prop in obj) {\n  console.log(prop);\t// ‘0’ ‘1’ ‘2’ 由此可见for in会自动添加下标\n}\n//for of遍历数组、字符串、Set、Map等\nvar a = [{a:1}, {b:2}, {c:3}];\nfor(let val of a) {\n\tconsole.log(val);\t// {a:1} {b:2} {c:3} 遍历出值\n}\n```\n\nfor...of其实隐式调用了Iterator方法（不断调用iterator.next()）\n\n执行效率：常规for循环 > forEach > for...of  >  map >  for...in\n\n### 面向对象Class\n\n1. ##### 构造函数\n\n   - 构造函数其实就是一个普通的函数。\n\n   - 构造函数的写法：函数体内用this声明一些共有属性，用.prototype来申明共有方法，用new 构造函数()创建一个对象继承构造函数的属性和方法。通过原型的继承，它节约了内存。\n\n   - js创建对象时都有一个_proto_的内置属性，它指向了构造函数的prototype。构造函数.prototype.constructor又指向构造函数本身\n\n     ```js\n     var person = function(name){\n        this.name = name\n      };\n     person.prototype.getName = function(){\n          console.log('名字是:'+this.name); \n     }\n     var aa = new person('cat');\n     var bb = new person('dog')\n     aa.getName(); \t//名字是:cat\n     bb.getName();\t//名字是:dog\n     console.log(aa.__proto__ === person.prototype);  //true\n     console.log(person.prototype.constructor === person);  //true\n     ```\n\n2. ##### Class\n\n   - 用class改造上面的构造函数。实例化一个对象的时候constructor里面的内容会执行一遍。\n\n   ```js\n   class person {\n       constructor(name) {\n           console.log('constructor执行了');\n           this.name = name;\n       }\n       getName() {\n           console.log('名字是:'+this.name);\n       }\n   }\n   var a = new person('cat');\n   var b = new person('dog');\n   a.getName();  //名字是:cat\n   b.getName();  //名字是:dog\n   ```\n\n   - class可以通过extends来继承，constructor内使用super()调用父类的构造方法\n\n     ```js\n     class personA extends person {\n     \tconstructor(name, food) {\n     \t\tsuper(name);\n     \t\tthis.food = food;\n     \t}\n     \tmyfood() {\n             console.log('吃东西：'+this.food)\n         }\n     }\n     var a = new personA('cat', 'apple');\n     a.myfood();\n     a.getName();\n     ```\n","tags":["js"],"categories":["项目总结"]},{"title":"Typescript 最佳实践","url":"/blog/2019/10/10/typescript-practice/","content":"\n### 不能忽略的options\n\n聊一下一些默认关闭着的、却又非常影响类型系统的实际效果的选项。下面这些选项，如果你有类型洁癖，都可以开启。若你想得到类型推导系统带来的好处，建议至少开启noImplicitAny和strictNullChecks。\n若你只想获得编辑器的提示，又不想陷入类型的泥淖中，可以保留默认值。\n\n+ noImplicitAny  当存在不明确的any时报错。\n+ noImplicitThis 当this 无法正确推导时报错\n+ alwaysStrict  在解析时使用严格模式，并且为每个文件增加 \"use strict\"\n+ strictBindCallApply  对使用bind 、call 和 apply 调用的函数进行严格的检查\n+ strictNullChecks 严格检查可空类型 （对于可以根据上下文逻辑，确定非空的地方，可使用感叹号!来去除类void的类型）。\n+ strictFunctionTypes 严格检查函数的参数 （主要针对参数继承的情况，用的比较少）\n+ strictPropertyInitialization  严格检查非空的类的属性是否都在constructor中进行初始化\n+ strict 开启noImplicitAny、noImplicitThis、alwaysStrict、strictBindCallApply、strictNullChecks、strictFunctionTypes和strictPropertyInitialization。\n+ noImplicitReturns 当不存在明确的return 语句时报错\n+ noUnusedLocals  当存在没有使用的局部变量时报错。\n+ noUnusedParameters  当存在没有使用的函数参数时报错（如果需要占位，可使用下划线_）。\n+ suppressImplicitAnyIndexErrors 对于隐式使用索引类型的地方进行检查\n+ suppressExcessPropertyErrors  是否检查过量的属性（酌情使用，建议开启）\n\n\n### 副作用 side effect\n\n前端开发始终都在和副作用作斗争。拿到底什么是副作用呢？举一个简单的例子就可以解释清楚了，假如我们写了一段代码，我们本地测试ok，就提交集成测试了，大多数比较正常的请款是测试失败。一般来说，失败的原因集中在，某种特殊的情况下，后端接口的返回与预期不一致。在这个例子中，API调用属于副作用的一种。通常意义上的副作用是，调用函数后，除了函数的返回值之外，还会对主调用函数产生附加影响。\n\n假如我们把整个页面应用看作一个函数，那么他的副作用一般来源于一下几个方面：\n\n+ 网络通信（http 调用， ws等）\n+ 文件或数据IO（localStorage、IndexedDB、sessionStorage、File等）\n+ 用户交互（按钮点击、表单输入、URL改变等）\n\n这些副作用时时刻刻在影响我们应用的状态，可以说是Bug的源泉。然而，我们却很少善待这一部分的工作。比如，我们通常喜欢快刀斩乱麻似的定义API的结构、然后进入开发环节；我们不假思索的将数据存储在localStorage确很少关心什么时候删除。\n\n遗憾的是，TS不会帮我们解决这些Bug，但它给我们提供了一个解决这些问题的思路，那就是在有Side Effect的地方定义更为明确的类型，比如：\n\n```typescript\n\n// 一般做法\nconst getDataFromStorage = (key: string) => {\n  const str = window.localStorage.getItem(key);\n  return str ? JSON.parse(str) : null;\n};\nconst someData = getDataFromStorage(\"DATA_KEY\");\n\n// 推荐做法\ninterface DataType {\n    name: string;\n    age: number;\n}\nfunction getDataFromStorage<T>(key: string): T | null {\n    const str = window.localStorage.getItem(key);\n    return str ? JSON.parse(str) : null;\n}\nconst someData = getDataFromStorage<DataType>(\"DATA_KEY\");\n\n```\n\n这里只列举了localStorage的情况，对于其他副作用，也是同样的。我们可以基于该例子推广到一般处理副作用的函数上，对于这里函数，最好能满足这些特点：\n\n+ 明确返回值的可能性，比如对于 getDataFromStorage 的返回值可能是 null 、也可能是 T类型\n+ 提供可定制的泛型参数，比如对于getDataFromStorage函数而言，根据key的参数不同，返回值的类型可能不同，这里我们可以用泛型提供这种定制的可能性。\n+ 提供明确的泛型类型，比如对于getDataFromStorage函数而言，这里明确了类型是DataType而不是由TS默认推导出的{}类型（在未来的TS版本中，它会被改为unknow类型）\n\n如果能够做到这几点，我无法保证项目中的Bug数量会降低一个数量级，但至少会让不清楚API历史的新人踩更少的坑，从而提高团队的效率。\n\n\n### 泛型优于联合类型（union type）\n\n联合类型可以说是在ts中最容易被滥用的类型之一。\n先看一个例子：\n\n```typescript\n\ninterface Bird {\n  fly(): void;\n  layEggs(): boolean;\n}\ninterface Fish {\n  swim(): void;\n  layEggs(): boolean;\n}\n// 获得小宠物，这里认为不能够下蛋的宠物是小宠物。现实中的逻辑有点牵强，只是举个例子。\nfunction getSmallPet(...animals: Array<Fish | Bird>): Fish | Bird {\n  for (const animal of animals) {\n    if (!animal.layEggs())\n      return animal;\n  }\n  return animals[0];\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay 因为layEggs是Fish | Bird 共有的方法\npet.swim(); // errors 因为swim是Fish的方法，而这里可能不存在\n\n```\n\n这个例子存在三个问题：\n\n+ 类型定义使getSmallPet变得局限。从代码逻辑看，它的作用是返回一个不下蛋的动物，返回的类型指向的是Fish或Bird。但我如果只想在一群鸟中挑出一个不下蛋的鸟呢？通过调用这个方法，我只能得到一个或者是Fish、或者是Bird的神奇生物。\n+ 代码重复、难以扩展。比如，我想再增加一个乌龟。我必须找到所有类似Fish | Bird的地方，然后把它修改为Fish | Bird | Turtle。\n+ 类型签名无法提供逻辑相关性。我们再审视一下类型签名，完全无法看出这里为什么是Fish | Bird而不是其它动物，它们两个到底和逻辑有什么关系才能够被放在这里。\n\n\n我们用泛型来解决这个问题：\n\n```typescript\n\n// 将共有的layEggs抽象到Eggable接口\ninterface Eggable {\n  layEggs(): boolean;\n}\ninterface Bird extends Eggable {\n  fly(): void;\n}\ninterface Fish extends Eggable {\n  swim(): void;\n}\n\n// 使用泛型，并用泛型约束声明接收的动物必须是继承了Eggable接口的类型，也展示了这个函数的作用范围是Eggable\nfunction getSmallPet<T extends Eggable>(...animals: Array<T>): T {\n  for (const animal of animals) {\n    if (!animal.layEggs())\n      return animal;\n  }\n  return animals[0];\n}\n// 可以用于继承了Eggable的任意类型，比如这里想找到鱼里面不能下蛋的鱼也是可以的\nlet pet = getSmallPet<Fish>();\npet.layEggs(); // okay\npet.swim(); // okay\n\n```\n\n\n### 巧用typeof优于自定义类型\n\n在副作用一节，强调了为副作用定义良好类型的重要性。这一节恰好相反，是为了强调在没有副作用的代码中，使用typeof偷懒的重要性。在前端页面，大多数数据来源于服务器，但有少部分数据是写死在前端的。对于这些写死的数据，除本系列第二篇文章提到一种处理手段外，我们有时候还需要这样的类型参与到计算中，这时，可以使用typeof来获取我们想要的类型。\n\n举个例子：\n比如，我们定义一个URL列表，并且要为类型是通知的标题加上[通知]两个子，代码如下：\n\n```typescript\n\nenum URLTypes {\n    NORMAL,\n    NOTIFICATION\n}\nconst urlconfigs = [\n    {\n        type: URLTypes.NORMAL,\n        title: \"普通页面\",\n        component: 'div'\n    },\n    {\n        type: URLTypes.NOTIFICATION,\n        title: \"通知页面\",\n        component: 'p'\n    }\n]\n\n// 提取urlconfigs 的类型 ，以便给getTitle函数使用\ntype UrlConfigItem = typeof urlconfigs[0];\n\nfunction getTitlte(item: UrlConfigItem, title: string) {\n    if(item.type === URLTypes.NOTIFICATION) {\n        return `[通知]-${title}`;\n    }\n    return title;\n}\n\n```\n\n这样，我们可以借助于TS，少些一些类型定义。另一个通常能够用到这个技巧的地方是类的函数，有时，我们希望将一个函数的返回值传给另一个函数，而这时我们又不想对函数接收的参数进行重复的类型定义，这种情况下，我们可以使用ReturnType获得函数的返回类型，然后用于另一个函数的参数。\n\n### 未完待续..\n\n","tags":["typescript","实战"],"categories":["typescript"]},{"title":"vue开发心得分享","url":"/blog/2019/10/09/vue-share/","content":"\n## 开发心得分享\n\n#### 思想\n\n######  做到不信任\n\n1. 对产品不信任（流程、细节）\n   - 在看原型、流程阶段把自己的疑问或想法都提出来，实际参与编码的人能站在代码层去考虑到一些产品想不到的问题，提前发现问题也是帮自己填坑\n\n   2. 对后端不信任（返回值、内容校验）\n       - 对于后端返回来的值一定要时刻记得判断非空、null判断，一般页面报错就是这么来的，后端说绝对不会是不可信的，百密一疏常有\n       - 一般来说提示信息由后端定义，或者前后端约定好，后端只返回错误代码，前端定义代码对应报错文案，避免出现调试类型的提示，这里也需要对报错文案进行空值判断\n\n#### 编码封装\n\n1. 前端字典，可以很好的保持统一性，B端项目效果显著。碰上某些场景部分字典不可用的状况下，可以封装一个方法，将不可用的值的key传入，返回可用的值的对象\n\n   ```js\n   // 设备类型\n   dict_device_type: [\n     {\n       key: 2,\n       value: '标准ICE-003'\n     },\n     {\n       key: 4,\n       value: '迷你ICE-004'\n     },\n   ]\n   // 使用起来直接复制粘贴，改个名字就行\n   <select v-for=\"item of dict_device_type\">\n     <options label=\"item.value\" value=\"item.key\"></options>\n   </select>\n   // 分页页码配置\n   dict_page_size: [10,20,30]\n   // 要修改分页配置的时候，可以一个地方修改，全局都改，保持统一\n   searchData = {\n     pageNum:1,\n     pageSize:dict_page_size\n   }\n   ```\n   \n\n   \n2. 工具类方法的提取\n\n   ```js\n   import Vue from 'vue'\n   const that = Vue.prototype\n   // 公用方法管理\n   const funs = {\n   \t/**\n        * 清空对象的所有属性的值\n        */\n       emptyObj(obj) {\n           if (typeof obj === 'object') {\n               for (let key of Object.keys(obj)) {\n                   obj[key] = '';\n               }\n               return obj;\n           }\n       },\n   \n       /**\n        * 本地存储（持久化）\n        */\n       setS(k, v, t) {\n           if (typeof v === \"object\") {\n               v = JSON.stringify(v);\n           }\n           if (t == 'session') {\n               window.sessionStorage.setItem(k, v);\n           } else {\n               window.localStorage.setItem(k, v);\n           }\n       }\n   }\n   that._fun = fun;\n   // 使用的时候直接引入\n   import 'util.js'\n   this._fun.setS('userInfo',{name:'张三',age:18})\n   ```\n\n   \n\n3. ui库的引用，新建一个专门的文件\n\n   ```js\n   import Vue from 'vue'\n   \n   import { Button, Divider, Form, message } from 'ant-design-vue'\n   Vue.use(Button);\n   Vue.use(Divider);\n   Vue.use(Form);\n   Vue.use(message);\n   \n   // 全局弹窗配置\n   message.config({\n     top: `120px`,\n     duration: 2,\n     maxCount: 3,\n   });\n   Vue.prototype.$message = message;\n   \n   // 入口引入：import './config/antDesign'\n   ```\n\n4. 表单校验的提取\n\n   ```js\n   // 定义项目中表单的规则\n   addOrderRules: {\n     name: [\n       { required: true, message: '请输入活动名称', trigger: 'blur' },\n       { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }\n     ],\n     region: [\n       { required: true, message: '请选择活动区域', trigger: 'change' }\n     ],\n     date1: [\n       { type: 'date', required: true, message: '请选择日期', trigger: 'change' }\n     ],\n     date2: [\n       { type: 'date', required: true, message: '请选择时间', trigger: 'change' }\n     ],\n     type: [\n       { type: 'array', required: true, message: '请至少选择一个活动性质', trigger: 'change' }\n     ],\n     resource: [\n       { required: true, message: '请选择活动资源', trigger: 'change' }\n     ],\n     desc: [\n       { required: true, message: '请填写活动形式', trigger: 'blur' }\n     ]\n   }\n   // 使用\n   <el-form :model=\"ruleForm\" :rules=\"addOrderRules\" ref=\"ruleForm\"></el-form>\n   ```\n\n   \n\n5. 高频率使用的方法挂载到实例上\n\n  ```js\n  // 工具类的挂载：Vue.prototype.funs = _funs;\n  ```\n\n6. 错误统一处理\n\n   - 在拦截器里面对200的业务错误和200以外的网络错误做统一报错处理\n\n   ```js\n   // 响应拦截\n   service.interceptors.response.use(function (response) {\n       // Do something with response data\n       if (response && response.data.return_code == '02') {\n           that.$message.error(response.data.return_msg || '请求失败')\n       }\n       return response;\n   }, function (error) {\n       // Do something with response error\n       const errObj = {\n           400:'错误请求',\n           401:'未授权，请重新登录',\n           403:'拒绝访问',\n           404:'请求错误，未找到该资源',\n           405:'请求方法未允许',\n           408:'请求超时',\n           500:'服务器出错',\n           501:'网络未实现',\n           502:'网络错误',\n           503:'服务不可用',\n           504:'网络超时',\n           505:'http版本不支持该请求'\n           \n       }\n       if (error && error.response) {\n         that.$message.error(errObj[error.response.status] || `连接错误\t\t\t\t\t${error.response.status}`);\n       } else {\n           that.$message.error('连接到服务器失败')\n       }\n       return Promise.reject(error);\n   });\n   ```\n\n\n\n#### 细节\n\n1. for循环性能\n\n   ```js\n   https://github.com/jawil/blog/issues/2\n   循环类型\t耗费时间(ms)\n   for\t约11.998\n   for cache\t约10.866\n   for 倒序\t约11.230\n   forEach\t约400.245\n   for in\t约2930.118\n   for of\t约320.921\n   正常推荐原始的for循环\n   for in 一般是用在对象属性名的遍历上的，由于每次迭代操作会同时搜索实例本身的属性以及原型链上的属性，所以效率低下\n   ```\n\n2. 原始for循环\n\n   ```js\n   // 保存数组的length长度\n   let len = arr.length\n   不要在for里面直接写\n   i < arr.length,这样每次循环都会去获取数组的length\n   ```\n\n3. 一次性函数\n\n   ```js\n   var sca = function () {\n       console.log('msg')\n       sca = function () {\n           console.log('new-msg')\n       }\n   }\n   sca() // msg\n   sca() // new-msg\n   sca() // new-msg\n   ```\n\n   \n\n\n\n","tags":["vue"],"categories":["vue"]},{"title":"HTML 书写规范","url":"/blog/2019/10/09/html/","content":"\n### 语法\n\n+ 缩进使用soft tab (4个空格) \n+ 嵌套节点应该缩进\n+ 在属性上，使用双引号，不要使用单引号\n+ 属性名全都小写，用中划线做分隔符\n+ 不要在自动闭合标签结尾处使用斜线（[HTML5规范](https://html.spec.whatwg.org/multipage/syntax.html#syntax-start-tag)指出他们是可选的）\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>Page title</title>\n    </head>\n    <body>\n        <img src=\"images/company_logo.png\" alt=\"Company\">\n\n        <h1 class=\"hello-world\">Hello, world!</h1>\n    </body>\n</html>\n```\n\n### HTML5 doctype\n\n在页面开头使用这个简单地doctype来启用标准模式，使其在每个浏览器中尽可能一致的展现；\n\n虽然doctype不区分大小写，但是按照惯例，doctype大写 ([关于属性时大写还是小写](https://stackoverflow.com/questions/15594877/is-there-any-benefits-to-use-uppercase-or-lowercase-letters-with-html5-tagname))\n\n### lang属性\n\n根据HTML5规范：\n\n> 应在html标签上加上lang属性。这会给语音工具和翻译工具帮助，告诉它们应当怎么去发音和翻译。\n\n更多关于 lang 属性的说明 [在这里](https://html.spec.whatwg.org/multipage/semantics.html#the-html-element)\n\n在sitepoint上可以查到 [语言列表](https://www.sitepoint.com/iso-2-letter-language-codes/)\n\n但sitepoint只是给出了语言的大类，例如中文只给出了zh，但是没有区分香港，台湾，大陆。而微软给出了一份更加详细的[语言列表](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/)，其中细分了zh-cn, zh-hk, zh-tw。\n\n```\n<!DOCTYPE html>\n<html lang=\"en-us\">\n    ...\n</html>\n```\n\n### 字符编码\n\n通过声明一个明确的字符编码，让浏览器轻松、快速的确定适合网页内容的渲染方式，通常指定为'UTF-8'。\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n    </head>\n    ...\n</html>\n```\n\n### IE兼容模式\n\n用 `meta` 标签可以指定页面应该用什么版本的IE来渲染\n如果你想要了解更多，请点击[这里](https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do)；\n\n不同doctype在不同浏览器下会触发不同的渲染模式（[这篇文章总结的很到位](https://hsivonen.fi/doctype/)）。\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n    </head>\n    ...\n</html>\n```\n\n### viewport\n我们在做响应式布局的时候，肯定要考虑到适配移动端的屏幕，大多数同学也一定复制粘贴过下面这段代码：\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n\n```\n添加了这段代码以后，我们在移动端看到的显示效果就非常好，整个页面不会缩成一团。但是很多时候我们只是拿来用了，没有去理解这段代码究竟干了什么，为什么会影响移动端页面的布局效果，它又是怎么起作用的。\n这篇[手记](https://www.imooc.com/article/34720)讲明白了，meta 标签viewport 的原理和作用\n\n### 引入CSS, JS\n根据HTML5规范, 通常在引入CSS和JS时不需要指明 type，因为 text/css和 text/javascript 分别是他们的默认值。\n\n```\n<!-- External CSS -->\n<link rel=\"stylesheet\" href=\"code_guide.css\">\n\n<!-- In-document CSS -->\n<style>\n    ...\n</style>\n\n<!-- External JS -->\n<script src=\"code_guide.js\"></script>\n\n<!-- In-document JS -->\n<script>\n    ...\n</script>\n```\n\n### 属性顺序\n\n属性应该按照特定的顺序出现以保证易读性；\n\n+ class\n+ id\n+ name\n+ data-*\n+ src , for, type, href, value, max-length, max, min, pattern \n+ placeholder, title, alt\n+ aria-*, role\n+ required, readonly, disabled\n\nclass是为高可复用组件设计的，所以应处在第一位；\n\nid更加具体且应该尽量少使用，所以将它放在第二位。\n\n```\n<a class=\"...\" id=\"...\" data-modal=\"toggle\" href=\"#\">Example link</a>\n\n<input class=\"form-control\" type=\"text\">\n\n<img src=\"...\" alt=\"...\">\n```\n\n### JS生成标签\n\n在JS文件中生成标签让内容变得更难查找，更难编辑，性能更差。应该尽量避免这种情况的出现。\n","tags":["html"],"categories":["项目总结"]},{"title":"Typescript 极速入门","url":"/blog/2019/10/09/typescript-start/","content":"\n### 基本类型和拓展类型\n\nTypescript 与 JavaScript 共享基本类型，拓展了一些类型\n\n+ 元组 Tuple\n+ 枚举 Enum\n+ any和void\n+ 从不类型 never\n\n#### 共有基本类型\n\n``` typescript\n\nlet a: number = 0;\nlet b: string = \"扫呗无线前端\";\nlet c: boolean = true;\nlet d: undefined = undefined;\nlet e: null = null;\n\n```\n\n#### object 类型，统指非number, string, null, undefined, boolean等基本类型的复杂类型\n\n```typescript\n\ndeclare function bar(arg: object | null): number;\n\nbar({});        //  ok\nbar(() => {});  //  ok\nbar(null);      //  ok\nbar(12121);     //  error\n\n// 或者这种写法\ninterface demofunc {\n    (arg: object): number\n}\nlet func: demofunc = (arg): number => {\n    return 1\n}\n\nfunc({}); // ok\nfunc(()=> {}) // ok\nfunc(null); // error\nfunc(12121) // error\nfunc(\"str\") // error\n\n// 数组\nlet arr: Array<string> = ['12121212']; // 数组泛型写法\nlet arr1: number[] = [1,2,3];    // 简写\n```\n\n#### 元组 Tuple\n\n元组类型允许你用固定数量的元素表示数组，这些元素的类型是已知的，但不必相同\n\n```typescript\n\n// 声明一个元组类型\nlet x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\n\n// 当我们去访问x 的值的时候, 如果访问到不存在的属性的时候，ts会立马给出错误提示\nconsole.log(x[0].substring(1)); // OK\nconsole.log(x[1].substring(1)); // Error, 'number' does not have 'substring'\n\n// 当越界访问x得时候\nx[3] = \"world\"; // Error, Property '3' does not exist on type '[string, number]'.\n\nconsole.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'.\n```\n\n#### enum 枚举\nenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\n// 默认情况从0开始为元素编号，也可手动为1开始\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n\nlet colorName: string = Color[2];\nconsole.log(colorName);  // 输出'Green'因为上面代码里它的值是2\n```\n\n枚举的应用场景适合定义一些固定的状态，比如应用得状态\n\n```typescript\n\nenum status {\n    isFetching,\n    pendding,\n    success,\n    error\n}\n\n```\n#### any和void、从不类型never\n+ any 用于不确定值得类型情况下，给变量定义any类型，但是不能多用，不然用ts就失去意义了\n+ void表示空值返回，比如\n```typescript\ndeclare function test(): void{\n    console.log(\"啥都没有返回\")\n}\n```\n+ never表示永远也到不了的情况，也叫从不类型\n```typescript\n\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// 函数返回绝不能具有无法到达的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n\n```\n\n#### 类型断言\n简略的定义是：可以用来手动指定一个值的类型。\n有两种写法，尖括号和as:\n\n```typescript\nlet bar: any = \"str\";\n\nlet len: number = (<string>bar).length;\nlet len1: number = (bar as string).length;\n```\n\n### 泛型 Generics\n\n先来看一个demo\n\n```typescript\nfunction demo(arg: number): number {\n    return arg\n}\n```\ndemo这个函数直接返回了传入的值，这个时候确定的是number类型，所以也直接返回了number类型\n软件工程的一个主要部分就是构建组件，构建的组件不仅需要具有明确的定义和统一的接口，同时也需要组件可复用。支持现有的数据类型和将来添加的数据类型的组件为大型软件系统的开发过程提供很好的灵活性。\n\n在C#和Java中，可以使用\"泛型\"来创建可复用的组件，并且组件可支持多种数据类型。这样便可以让用户根据自己的数据类型来使用组件。\n\n#### 泛型方法\n\n在ts里，声明泛型方法\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n调用泛型方法\n\n```typescript\nidentity<string>(\"112121\");\n\n// 或者\nidentity(\"12121\");  // 编译器会根据传入参数来自动识别对应的类型。\n\n```\n\n#### 泛型与any\ntypescript的特殊类型any在使用的时候可以代替任意的类型，看似和泛型很像，但实际上有很大差别\n\n```typescript\nfunction anyDemo(arg: any):any {\n    console.log(arg.length);\n    return arg;\n}\n\nfunction genericsDemo<T>(arg: Array<T>): Array<T> {\n    console.log(arg.length);\n    return arg;\n}\n```\n+ anyDemo, 因为arg的类型是any,所以可以打印length属性，但是如果arg的实际输入类型不是带有length属性的变量，会抛出异常\n+ genericsDemo， 定义了arg类型是数组的泛型类型，所以一定有length属性，所以不会抛出异常\n\n\n###  自定义类型类型\n\n#### interface 与 type的区别\n\n##### 相同点\n\n###### 都可以描述一个对象或函数\n\n```typescript\n// interface\ninterface Blog{\n    title: string;\n}\ninterface funcs {\n    (name: string): void; \n}\nlet bar:funcs = function (name) {\n    console.log(name)\n}\nbar(\"12121\")\n\n// type\ntype Blog = {\n    title: string;\n}\ntype funcs = (name: string) => void\n\nlet bar: funcs = function (name) {\n    console.log(name)\n}\nbar(\"112121\")\n\n```\n\n###### 拓展（extends）与 交叉类型（Intersection Types）\ninterface是可以extends,但是type是不允许extends和implement的。但是type却可以通过交叉类型实现interface 的extends行为，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 与 interface 类型 交叉 。\n虽然效果差不多，但是两者语法不同。\n\n```typescript\n// interface extends interface\ninterface Name { \n  name: string; \n}\ninterface User extends Name { \n  age: number; \n}\n\n\n// type 与 type交叉\ntype Name = { \n  name: string; \n}\ntype User = Name & { age: number  };\n\n\n// interface extends type\ntype Name = { \n  name: string; \n}\ninterface User extends Name { \n  age: number; \n}\n\n\n// type 与 interface 交叉\ninterface Name { \n  name: string; \n}\ntype User = Name & { \n  age: number; \n}\n\n```\n\n##### 不同点\n\n\n###### type 可以而 interface 不行\n\n+ type 可以声明基本类型别名，联合类型，元组等类型\n\n```typescript\n// 基本类型别名\ntype Name = string;\n\n// 联合类型\ntype status = string | number\n\n// 元组\ntype arr = [string, number]\n```\n\n+ type 语句中还可以使用 typeof 获取实例的 类型进行赋值\n\n```typescript\n\n// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createElement('div');\ntype B = typeof div\n\n```\n\n+ 其他骚操作\n\n```typescript\n\ntype StringOrNumber = string | number;  \ntype Text = string | { text: string };  \ntype NameLookup = Dictionary<string, Person>;  \ntype Callback<T> = (data: T) => void;  \ntype Pair<T> = [T, T];  \ntype Coordinates = Pair<number>;  \ntype Tree<T> = T | { left: Tree<T>, right: Tree<T> };\n\n```\n\n###### interface 可以而 type 不行\n\n```typescript\n// interface 能够声明合并\ninterface User {\n  name: string\n  age: number\n}\n\ninterface User {\n  sex: string\n}\n\n/*\nUser 接口为 {\n  name: string\n  age: number\n  sex: string \n}\n*/\n\n```\n\n### 实现与继承： implements 和 extends\n\nextends 很明显就是ES6里面的类继承，那么implements 又是做什么的？他和extends有什么不同？\nimplements 实现。与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约\n\nimplements 基本方法：\n\n```typescript\ninterface Bar {\n    name: string;\n    age?: number;\n}\n\n// ok\nclass bar implements Bar {\n    name = '扫呗无限前端';\n}\n// ok\nclass bar2 implements Bar {\n    name = '扫呗无限前端';\n    age = 18\n}\n// error \nclass bar3 implements Bar {\n    name = '扫呗无限前端';\n    age = '18'\n}\n\n```\n\n而， extends 是继承父类，两者其实可以混用：\n\n```typescript\n\ninterface Fun {\n    name: string;\n    title: string;\n}\ninterface Bar {\n    age: number;\n}\nclass B {\n    sex = 'man';\n}\nclass A extends B implements Fun,Bar {\n    name = '扫呗无限前端';\n    title = 'web前端攻城狮';\n    age = 18\n}\n\n```\n\n### 声明文件与命名空间： declare 和 namespace\n\n比如Vue项目中的 shims-tsx.d.ts 和 shims-vue.d.ts ，其初始内容是这样的：\n\n```typescript\n\n// shims-tsx.d.ts\nimport Vue, { VNode } from 'vue';\n\ndeclare global {\n  namespace JSX {\n    // tslint:disable no-empty-interface\n    interface Element extends VNode {}\n    // tslint:disable no-empty-interface\n    interface ElementClass extends Vue {}\n    interface IntrinsicElements {\n      [elem: string]: any;\n    }\n  }\n}\n\n// shims-vue.d.ts\ndeclare module '*.vue' {\n  import Vue from 'vue';\n  export default Vue;\n}\n\n\n```\n\n` declare `: 当使用第三方库时，我们需要引用他的声明文件，才能获得对应的代码补全，接口提示等功能。\n\n```typescript\n\ndeclare var         // 声明全局变量\ndeclare function    // 声明全局方法\ndeclare class       // 声明全局类\ndeclare enum        // 声明全局枚举类型\ndeclare global      // 扩展全局变量\ndeclare module      // 扩展模块\n\n```\n\n` namespace `：“内部模块”现在称做“命名空间”\n\n`module X { `  相当于现在推荐的写法 `namespace X {)`\n\n\n### Typescript3.7已发布，新特性有些哪些？\n\n#### Optional chaining (可选链)\n\n```typescript\n\n//在3.7的发展期间，可选链达到了TC39第3阶段的共识\n// 可选链接命中 null 或 undefined 会立即停止运行代码\ntype AlbumAPIResponse = {\n  title: string\n  artist?: {\n    name: string\n    bio?: string\n    previousAlbums?: string[]\n  }\n};\ndeclare const album: AlbumAPIResponse;\n\n// 可选链的写法\nconst artistBio = album?.artist?.bio;\n\n// 而不是:\nconst maybeArtistBio = album.artist && album.artist.bio;\n\n\n// 在访问元素属性时也可与操作符 [] 一起使用\nconst maybeArtistBioElement = album?.[\"artist\"]?.[\"bio\"];\nconst maybeFirstPreviousAlbum = album?.artist?.previousAlbums?.[0];\n\n// 处理可能不存在的函数的时候\nconst callUpdateMetadata = (metadata: any) => Promise.resolve(metadata); // Fake API call\nconst updateAlbumMetadata = async (metadata: any, callback?: () => void) => {\n  await callUpdateMetadata(metadata);\n  callback?.();\n};\n\n```\n\n####  Nullish Coalescing （空值合并）\n\n空值合并运算符是 || 的替代方法， 如果左边是 null 或 undefined 就返回右边；\n看一个例子：\n\n```typescript\n\ninterface AppConfiguration {\n  // Default: \"(no name)\"; empty string IS valid\n  name:  string;\n\n  // Default: -1; 0 is valid\n  items:  number;\n\n  // Default: true\n  active: boolean;\n}\n\n// Partial 把接口字段都转为可选\n\nfunction updateApp(config: Partial<AppConfiguration>) {\n  // With null-coalescing operator\n  config.name = config.name ?? \"(no name)\";\n  config.items = config.items ?? -1;\n  config.active = config.active ?? true;\n\n  // 当前的解决办法\n  config.name = typeof config.name === \"string\" ? config.name : \"(no name)\";\n  config.items = typeof config.items === \"number\" ? config.items : -1;\n  config.active = typeof config.active === \"boolean\" ? config.active : true;\n\n  // 使用 || 会出现判断错误\n  config.name = config.name || \"(no name)\"; // does not allow for \"\" input\n  config.items = config.items || -1; // does not allow for 0 input\n  config.active = config.active || true; // really bad, always true\n}\n\n```\n\n等等...\n\n","tags":["typescript"],"categories":["typescript"]},{"title":"CSS — BEM 命名规范","url":"/blog/2019/10/09/css-BEM/","content":"\n### 什么是BEM 命名规范\n+ [Bem](https://en.bem.info/) 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\n\n>  -中划线：仅作为连接符使用，表示某个块或者某个子元素的多单词之间的连接记号\n\n>  __ 双下划线：双下划线用来连接块和块的子元素\n\n> _ 单下划线：单下划线用来描述一个块和一个块或块的子元素的一种状态\n\ntype-block__element_modifier\n\n### 块（block）\n\n一个块是设计或布局的一部分，它具有具体且唯一的意义，要么是语义上要么是视觉上\n在大多数情况下，任何独立的页面元素（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个唯一的CSS类名，也就是这个块的名字。\n针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似 命名空间 的作用\n\n一个块的正式（实际上是半正式的）定义有下面三个基本原则：\n\n1. css中只能使用类名（不能是ID）\n2. 每一个块名应该有一个命名空间（前缀）\n3. 每一条CSS规则必须属于一个块。\n\n例如：一个自定义列表 .list 是一个块，通常自定义列表是算在 module 类别的，在这种情况下，一个 list 列表的block写法应该为:\n\n```\n.list\n```\n\n### 元素（element）\n\n块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀。\n\n如上面的例子，li.item 是列表的一个子元素，\n\n```\n // 普通写法\n .list{}\n .list .item{}\n\n // BEM 写法\n .list{}\n .list__item{}\n```\n\n### 修饰符（modifier）\n\n一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性。\n用一个例子来解释最好不过了。一个表示按钮的块默认有三个大小：小，中，大。为了避免创建三个不同的块，最好是在块上加修饰符。这个修饰符应该有个名字（比如：size ）和值（ small，normal 或者 big ）。\n如上面的例子中，表示一个选中的列表，和一个激活的列表项\n\n```\n// 普通写法\n.list{}\n.list.select{}\n.list .item{}\n.list .item.active{}\n\n// BEM 写法\n.list{}\n.list_select{}\n.list__item{}\n.list__item_active{}\n```\n\n\n### LESS 书写规范\n\n使用 .less 后缀的文件来存储变量、混合代码以及最终合并压缩。  \n\n|  子less | 注解 |\n|:-----|-----:|\n|`lib-base.less`    |  预定义的变量，例如颜色、字号、字体      |\n|`lib-mixins.less`  |  用于混合的代码，例如渐变、半透明的混合    |\n|`lib-reset.less`   |  初始化                                |\n|`lib-ui.less`      |  颗粒化ui功能                           |\n|`xxx.less`         |  模块样式                                |\n\n.less 文件的引用顺序会对最终编译的样式的作用域和优先级产生影响，请尽量按照由底层到自定义的顺序来引用。\n\n### 关于风格\n\n##### 1. 原则上不会出现2层以上选择器嵌套\n使用BEM原则，用命名来解耦，所有类名都为一层，增加效率和复用性\n\n##### 2. 两层选择器嵌套出现在.mod-xxx__item_current子元素的情况，如下：\n使用推荐的嵌套写法\n\n```\n// 常规写法：\n.xxx{}\n.xxx__item{}\n.xxx__item_current{}\n// 嵌套写法\n.xxx__item_current .mod-xxx__link{}\n\n// 推荐\n.xxx{}\n.xxx__item{}\n.xxx__item_hightlight{}\n.xxx__product-name{}\n.xxx__link{}\n.xxx__ming-zi-ke-yi-hen-chang{}\n\n// 嵌套写法\n.xxx__item_current{\n    .xxx__link{}\n}\n\n\n```\n\n对应HTML 结构如下\n\n```\n<ul class=\"xxx\">\n    <li class=\"xxx__item\">第一项\n        <div class=\"xxx__product-name\">我是名称</div>\n        <span class=\"xxx__ming-zi-ke-yi-hen-chang\">看类名</span>\n        <a href=\"#\" class=\"xxx__link\">我是link</a>\n    <li>\n    <li class=\"xxx__item xxx__item_current\">第二项 且 当前选择项\n        <div class=\"xxx__product-name\">我是名称</div>\n        <a href=\"#\" class=\"xxx__item-link\">我是link</a>\n    <li>\n    <li class=\"xxx__item xxx__item_hightlight\">第三项 且 特殊高亮\n         <div class=\"xxx__product-name\">我是名称</div>\n        <a href=\"#\" class=\"xxx__item-link\">我是link</a>\n    <li>\n</ul>\n```\n\n\n### BEM 解决问题\n组件之间的完全解耦，不会造成命名空间的污染，如：.mod-xxx ul li 的写法带来的潜在的嵌套风险。\n\n### 性能\nBEM 命名会使得 Class 类名变长，但经过 gzip 压缩后这个带宽开销可以忽略不计\n\n```\nxxx__item_hightlight\n```","tags":["css"],"categories":["项目总结"]}]